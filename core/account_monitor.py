#!/usr/bin/env python3
# core/account_monitor.py

import asyncio
import time
from typing import Dict, Optional
from telethon import TelegramClient
from telethon.errors import FloodWaitError, UserDeactivatedError, AuthKeyUnregisteredError
from utilities.log_utils import log_event
from utilities.anti_spam_guard import anti_spam_guard

class AccountMonitor:
    def __init__(self):
        self.monitoring_active = {}  # {username: bool}
        self.last_spambot_check = {}  # {username: timestamp}
        self.account_health = {}  # {username: {"status": "healthy|warning|banned", "last_check": timestamp}}
        
        # Check intervals
        self.SPAMBOT_CHECK_INTERVAL = 21600  # 6 saat
        self.HEALTH_CHECK_INTERVAL = 3600   # 1 saat

    async def start_monitoring(self, client: TelegramClient, username: str):
        """Hesap izlemeyi ba≈ülat"""
        self.monitoring_active[username] = True
        log_event(username, "üîç Hesap izleme ba≈ülatƒ±ldƒ±")
        
        # Monitoring loop'u ba≈ülat
        asyncio.create_task(self._monitoring_loop(client, username))

    async def stop_monitoring(self, username: str):
        """Hesap izlemeyi durdur"""
        self.monitoring_active[username] = False
        log_event(username, "üõë Hesap izleme durduruldu")

    async def _monitoring_loop(self, client: TelegramClient, username: str):
        """Ana izleme d√∂ng√ºs√º"""
        while self.monitoring_active.get(username, False):
            try:
                # SpamBot kontrol√º
                await self._check_spambot_status(client, username)
                
                # Genel saƒülƒ±k kontrol√º
                await self._check_account_health(client, username)
                
                # 1 saat bekle
                await asyncio.sleep(self.HEALTH_CHECK_INTERVAL)
                
            except Exception as e:
                log_event(username, f"‚ùå Monitoring loop hatasƒ±: {e}")
                await asyncio.sleep(300)  # 5 dakika bekle ve devam et

    async def _check_spambot_status(self, client: TelegramClient, username: str):
        """@SpamBot'tan durum kontrol√º"""
        current_time = time.time()
        last_check = self.last_spambot_check.get(username, 0)
        
        # 6 saatte bir kontrol et
        if current_time - last_check < self.SPAMBOT_CHECK_INTERVAL:
            return
        
        try:
            log_event(username, "ü§ñ @SpamBot durumu kontrol ediliyor...")
            
            # SpamBot'a mesaj g√∂nder
            spambot = await client.get_entity("@SpamBot")
            await client.send_message(spambot, "/start")
            
            # Yanƒ±t bekle (5 saniye)
            await asyncio.sleep(5)
            
            # Son mesajlarƒ± al
            messages = await client.get_messages(spambot, limit=3)
            
            spam_detected = False
            warning_message = ""
            
            for message in messages:
                if message.text:
                    text_lower = message.text.lower()
                    
                    # Spam uyarƒ± kelimelerini kontrol et - ama pozitif mesajlarƒ± hari√ß tut
                    warning_keywords = [
                        "spam", "flood", "restricted", 
                        "warning", "violation", "abuse", "banned"
                    ]
                    
                    # Pozitif mesajlarƒ± hari√ß tut
                    positive_phrases = [
                        "good news", "no limits", "free as a bird", 
                        "all clear", "no restrictions"
                    ]
                    
                    # Pozitif mesaj deƒüilse ve uyarƒ± kelimesi varsa spam olarak i≈üaretle
                    is_positive = any(phrase in text_lower for phrase in positive_phrases)
                    has_warning = any(keyword in text_lower for keyword in warning_keywords)
                    
                    # Debug log ekle
                    log_event(username, f"üîç SpamBot mesaj analizi: '{text_lower[:50]}...'")
                    log_event(username, f"üîç Pozitif: {is_positive}, Uyarƒ±: {has_warning}")
                    
                    if has_warning and not is_positive:
                        spam_detected = True
                        warning_message = message.text
                        log_event(username, f"üö® Spam tespit edildi: pozitif={is_positive}, uyarƒ±={has_warning}")
                        break
                    elif is_positive:
                        log_event(username, f"‚úÖ Pozitif mesaj tespit edildi, spam deƒüil")
                        break
            
            if spam_detected:
                log_event(username, f"‚ö†Ô∏è SPAM UYARISI TESPƒ∞T EDƒ∞LDƒ∞: {warning_message}")
                
                # Anti-spam guard'a uyarƒ± ekle
                anti_spam_guard.add_spam_warning(username, "spambot_warning")
                
                # Hesap durumunu g√ºncelle
                self.account_health[username] = {
                    "status": "warning",
                    "last_check": current_time,
                    "warning_message": warning_message
                }
                
                # Acil m√ºdahale
                await self._emergency_response(username, "spambot_warning")
                
            else:
                log_event(username, "‚úÖ @SpamBot kontrol√º temiz")
                self.account_health[username] = {
                    "status": "healthy",
                    "last_check": current_time
                }
            
            self.last_spambot_check[username] = current_time
            
        except Exception as e:
            log_event(username, f"‚ùå SpamBot kontrol hatasƒ±: {e}")

    async def _check_account_health(self, client: TelegramClient, username: str):
        """Genel hesap saƒülƒ±ƒüƒ± kontrol√º"""
        try:
            # Basit API √ßaƒürƒ±sƒ± ile hesap durumunu test et
            me = await client.get_me()
            
            if me:
                log_event(username, "üíö Hesap saƒülƒ±ƒüƒ±: Normal")
                return True
            else:
                log_event(username, "üíî Hesap saƒülƒ±ƒüƒ±: Sorunlu")
                return False
                
        except UserDeactivatedError:
            log_event(username, "üö´ HESAP DEVRE DI≈ûI BIRAKILDI!")
            await self._emergency_response(username, "account_deactivated")
            return False
            
        except AuthKeyUnregisteredError:
            log_event(username, "üîë AUTH KEY GE√áERSƒ∞Z!")
            await self._emergency_response(username, "auth_invalid")
            return False
            
        except FloodWaitError as e:
            log_event(username, f"üåä Flood wait: {e.seconds}s")
            # Flood wait normal bir durum, uyarƒ± verme
            return True
            
        except Exception as e:
            log_event(username, f"‚ùå Saƒülƒ±k kontrol√º hatasƒ±: {e}")
            return False

    async def _emergency_response(self, username: str, emergency_type: str):
        """Acil durum m√ºdahalesi"""
        log_event(username, f"üö® ACƒ∞L DURUM: {emergency_type}")
        
        if emergency_type == "spambot_warning":
            # Spam uyarƒ±sƒ± alƒ±ndƒ± - spam'i durdur
            log_event(username, "üõë Spam durduruldu - g√ºvenlik modu aktif")
            
            # Bot profilini g√ºvenli moda al
            await self._set_safe_mode(username, True)
            
        elif emergency_type == "account_deactivated":
            # Hesap devre dƒ±≈üƒ± - tamamen durdur
            log_event(username, "üö´ Hesap tamamen devre dƒ±≈üƒ± bƒ±rakƒ±ldƒ±")
            await self.stop_monitoring(username)
            
        elif emergency_type == "auth_invalid":
            # Auth key ge√ßersiz - session yenilenmeli
            log_event(username, "üîë Session yenilenmesi gerekiyor")
            await self.stop_monitoring(username)

    async def _set_safe_mode(self, username: str, enabled: bool):
        """G√ºvenli mod ayarla"""
        try:
            # Bot profilini g√ºncelle
            import json
            from pathlib import Path
            
            profile_path = Path(f"data/personas/{username}.json")
            if profile_path.exists():
                with open(profile_path, "r", encoding="utf-8") as f:
                    profile = json.load(f)
                
                if enabled:
                    profile["autospam"] = False
                    profile["reply_mode"] = "manual"  # Sadece manuel yanƒ±t
                    profile["safe_mode"] = True
                    log_event(username, "üõ°Ô∏è G√ºvenli mod aktifle≈ütirildi")
                else:
                    profile["safe_mode"] = False
                    log_event(username, "üîì G√ºvenli mod devre dƒ±≈üƒ± bƒ±rakƒ±ldƒ±")
                
                with open(profile_path, "w", encoding="utf-8") as f:
                    json.dump(profile, f, indent=2, ensure_ascii=False)
                    
        except Exception as e:
            log_event(username, f"‚ùå G√ºvenli mod ayarlama hatasƒ±: {e}")

    def get_account_status(self, username: str) -> Dict:
        """Hesap durumu raporu"""
        health = self.account_health.get(username, {"status": "unknown", "last_check": 0})
        anti_spam_status = anti_spam_guard.get_account_status(username)
        
        return {
            "username": username,
            "monitoring_active": self.monitoring_active.get(username, False),
            "health_status": health["status"],
            "last_health_check": health.get("last_check", 0),
            "last_spambot_check": self.last_spambot_check.get(username, 0),
            "warning_message": health.get("warning_message"),
            "anti_spam": anti_spam_status
        }

    async def manual_spambot_check(self, client: TelegramClient, username: str):
        """Manuel SpamBot kontrol√º"""
        log_event(username, "üîç Manuel SpamBot kontrol√º ba≈ülatƒ±ldƒ±")
        await self._check_spambot_status(client, username)

    async def reset_warnings(self, username: str):
        """Uyarƒ±larƒ± sƒ±fƒ±rla"""
        anti_spam_guard.spam_warnings[username] = []
        self.account_health[username] = {
            "status": "healthy",
            "last_check": time.time()
        }
        log_event(username, "üîÑ Uyarƒ±lar sƒ±fƒ±rlandƒ±")

# Global instance
account_monitor = AccountMonitor() 